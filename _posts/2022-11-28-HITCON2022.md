---
layout: post
title:  "HITCON 2022"
date:   2022-11-28
excerpt: "Simple Jekyll theme for your blog by Taylan Tatlƒ±."
tag:
- ctf 
- writeup
- hitcon
- cryptography
- reverse
---

{% include toc.html %}

# CRYPTOGRAPHY
Author: m1dm4n
# BabySSS - Crypto - 94 solves
## Description
> I implemented a toy Shamir's Secret Sharing for fun. Can you help me check is there any issues with this?
> 
> Author: maple3142

<div markdown="0"><a href="https://github.com/m1dm4n/CTF-WriteUp/blob/main/2022/HITCONCTF2022/babysss/babysss-1068a45edf321eee75c9ceb3241a9941ab8bdc07.tar.gz" class="btn">Attachments</a></div>

### Solution
First look at the source file:
```python
from random import SystemRandom
from Crypto.Cipher import AES
from hashlib import sha256
from secret import flag

rand = SystemRandom()


def polyeval(poly, x):
    return sum([a * x**i for i, a in enumerate(poly)])


DEGREE = 128
SHARES_FOR_YOU = 8  # I am really stingy :)

poly = [rand.getrandbits(64) for _ in range(DEGREE + 1)]
shares = []
for _ in range(SHARES_FOR_YOU):
    x = rand.getrandbits(16)
    y = polyeval(poly, x)
    shares.append((x, y))
print(shares)

secret = polyeval(poly, 0x48763)
key = sha256(str(secret).encode()).digest()[:16]
cipher = AES.new(key, AES.MODE_CTR)
print(cipher.encrypt(flag))
print(cipher.nonce)
```
We can see that it's a Shamir‚Äôs Secret Sharing but in on Integer field ($$\mathbb{ZZ}$$). The challenge give us 8 shares and ask us to recover all 129 coefficients of poly.

Each shares give to us have a form like this:
$$
(x_i, y_i) = (x_i, a_{129}x_i^{128} + a_{128}x_i^{127}+...+a_{2}x_i + a_{1})
$$

So basically for each share $$i$$ if you get $$y_i \% x_i$$, you will get $$a_1\%x_i$$ . With 8 shares you could use **CRT** (Chinese Remainder Theorem) to recover a1 and then subtract that a1, divide $$x_i$$ and countinue to do that until you have all 129 coefficients

All coefficients in poly are 64-bit integers and all shared *$$x_i$$ are 16-bit integer but we have 8 shares so it's enough for us to recover each coefficients.

- [Script](https://github.com/m1dm4n/CTF-WriteUp/blob/main/2022/HITCONCTF2022/babysss/solve.py)
- Output:
```python
b'hitcon{doing_SSS_in_integers_is_not_good_:(}'
```


# Secret - Crypto - 41 solves
## Description
> Too many secrets ...
> 
> Author: lyc

[Attachments](https://github.com/m1dm4n/CTF-WriteUp/blob/main/2022/HITCONCTF2022/secret/secret-e35f5c21e032b74b1ab8110722c593847c2534cb.zip)

### Solution

My basic idea is from this latest [N1CTF](https://tl2cents.github.io/2022/11/08/N1CTF-2022-Crypto-Writeups-By-tl2cents/). We will use lattice to recover the modulus $$p$$ then recover the modulus $$N$$ and decrypt flag.

#### Recover modulus p

Why we need recover $$p$$ first?

Well you can in see the source code that the public key is $$p + e_i$$ and we don't know $$p$$ but we know all $$e_i$$. So if we get $$c_i$$ (i'th ciphertext) modulo with $$p$$, we will get $$c_i\equiv m^{p+e_i}\equiv m^{e_i + 1}\pmod{p}$$.

All $$e_i$$ are 512-bit integer so it's too big for us to apply direct power so we will construce a lattice to narrow down the exponents. The lattice is as follows:

$$
M = \begin{bmatrix}
e_1 & 1 & 0 &... & 0 \\
e_2 & 0 & 1 &... & 0 \\
\vdots & \vdots & \vdots& \ddots & \vdots \\
e_{64} & 0 & 0 &... & 1 \\
\end{bmatrix} 
$$

And than apply the LLL algorithm to $$M$$ will give you all small linear combinations (list $$k_i$$) of all rows in $$M$$. Define $$ML=M.LLL()$$ and $$ML_i$$ will be the i'th row of $$ML$$, $$ML_i$$ will have the form $$[r_i, k_{i1}, k_{i2}, \ldots, k_{i64} ]$$ such that:

$$
r_i = \sum\limits_{j=1}^{64} e_j*k_{ij}
$$

And the most important that $$k_i$$ is small so we can apply the power direct to $$c_i$$. Since we don't have $$m_i$$, we can't apply the exponent $$r_i$$. But we was given 64 $$c_i$$ and $$e_i$$ so we can find a pair $$r_i$$ and $$r_j$$ such that

$$
\begin{equation}
k_1*r_i = k_2*r_j 
\iff m^{k_1*r_i} = m^{k_2*r_j}
\iff m^{k_1*r_i} - m^{k_2*r_j} = K*p = 0 \pmod{p} 
\end{equation}
$$

And $$m^{r_{i}}$$ can simple calculate since we have linear combination of list $$e_i$$:

$$
\begin{align}
e_1*k_{i1} + e_2*k_{i2} + \cdots + e_{64}*k_{i64} &= r_i\\
\iff m^{e_1*k_{i1} + e_2*k_{i2} + \cdots + e_{64}*k_{i64}} &= m^{r_i} \\
\end{align}
$$

Note: since $$k_{ij}$$ can be negative or positive, we should seperate the list $$k_i$$ into 2 list: `pos` and `neg`. The equaltion will like this:

$$
m^{r_i} = \
\begin{cases}
\frac{m^{epos_1*pos_{i1} + epos_2*pos_{i2} + \cdots + epos_{64}*pos_{i64}}}{m^{eneg_1*neg_{i1} + eneg_2*neg_{i2} + \cdots + eneg_{64}*neg_{i64}}} \ \text{if }r_i > 0 \\
\frac{m^{eneg_1*neg_{i1} + eneg_2*neg_{i2} + \cdots + eneg_{64}*neg_{i64}}}{m^{epos_1*pos_{i1} + epos_2*pos_{i2} + \cdots + epos_{64}*pos_{i64}}} \ \text{if }r_i < 0
\end{cases}
$$

So if we get enough $$K_i*p$$, we could get **GCD** the list of it and get the modulus $$p$$ 

Code:
```python
def solve(ess, bit_need):
    L = len(ess)
    M1 = matrix.identity(ZZ, L)
    mates = matrix(ZZ, L, 1)
    for i, e in enumerate(ess):
        mates[i, 0] = e
    mat = block_matrix(ZZ, [mates, M1], ncols=2)
    mat = mat.LLL()
    # for row in mat:
    #     logging.info(row)
    ns = []
    for row1, row2 in combinations(list(mat.rows()), 2):
        a, b = abs(row1[0]), abs(row2[0])
        k1, k2 = 1, 1
        if a % b == 0:
            k2 *= a // b
        elif b % a == 0:
            k1 *= b // a
        else:
            continue
        try:
            logging.info(f"Found a good pair: a = {row1[0]}, b = {row2[0]}")
            k1 = compute(row1)**k1
            k2 = compute(row2)**k2
            ns.append(mpz((k1 - k2).numerator()))
        except ValueError:
            continue
        if len(ns) > 2:
            p = gcd(*ns)
            logging.debug(f"Found a gcd with {p.bit_length()} bits")
            if p.bit_length() <= bit_need:
                return p
    return p
new_es = []
for e in es:
    new_es.append(e + 1)
p = solve(new_es, 1024)
logging.debug(f"Found p: {p}")
```
```python
[INFO]: Found a good pair: a = 84, b = 42
[INFO]: Found a good pair: a = -224, b = 112
[INFO]: Found a good pair: a = -224, b = 56
[DEBUG]: Found a gcd with 29601 bits
[INFO]: Found a good pair: a = -24, b = -120
[DEBUG]: Found a gcd with 1024 bits
[DEBUG]: Found p: 114123489471785231935784934808971699969409921187241213856052699152350022529522625133249122600992294384493330729753558097354310956450782137388609095123051712848950720360020186805006589596948820312938610934162552701552428320073591829720623902109809701883779673050594202312941073709061911680769616320309646800153
```

#### Recover modulus N

Since we have $$p$$, we just need change the argument for the `solve` function to list of $$p + e_i$$ and number of bits that we need will be $$2048$$

```python
new_es = []
for e in es:
    new_es.append(e + p)
n = solve(new_es, 2048)
logging.debug(f"Found n: {n}")
```
```python
[INFO]: Found a good pair: a = 292, b = 4
[INFO]: Found a good pair: a = 66, b = 11
[INFO]: Found a good pair: a = 66, b = 198
[DEBUG]: Found a gcd with 542856 bits
[INFO]: Found a good pair: a = 66, b = -330
[DEBUG]: Found a gcd with 408759 bits
[INFO]: Found a good pair: a = 52, b = -156
[DEBUG]: Found a gcd with 34762 bits
[INFO]: Found a good pair: a = 52, b = -104
[DEBUG]: Found a gcd with 34762 bits
[INFO]: Found a good pair: a = 52, b = 4
[DEBUG]: Found a gcd with 34762 bits
[INFO]: Found a good pair: a = 52, b = 260
[DEBUG]: Found a gcd with 2048 bits
[DEBUG]: Found n: 17724789252315807248927730667204930958297858773674832260928199237060866435185638955096592748220649030149566091217826522043129307162493793671996812004000118081710563332939308211259089195461643467445875873771237895923913260591027067630542357457387530104697423520079182068902045528622287770023563712446893601808377717276767453135950949329740598173138072819431625017048326434046147044619183254356138909174424066275565264916713884294982101291708384255124605118760943142140108951391604922691454403740373626767491041574402086547023530218679378259419245611411249759537391050751834703499864363713578006540759995141466969230839
```

#### Decrypting flag
We have $$N$$ and $$p$$ so we just find $$e$$ in the list $$es$$ such that $$\mathbb{GCD}(p+e, (p-1)*(q-1))=1$$ and then using basic RSA decryption to get flag

```python
q = n//p
phi = (p-1)*(q-1)
for e in es:
    if gcd(p+e, phi) != 1:
        continue
    d = inverse(p+e, phi)
    logging.debug("FLAG: hitcon{" + long_to_bytes(
        pow(cs[es.index(e)], d, n)).split(b'hitcon{')[-1].decode().strip())
    break
```
```python
[DEBUG]: FLAG: hitcon{K33p_ev3rythIn9_1nd3p3ndent!}
```

[Script](https://github.com/m1dm4n/CTF-WriteUp/blob/main/2022/HITCONCTF2022/secret/solve.sage)

# RCE - Web - 157 solves

> Hello, I am a Random Code Executor, I can execute r4NdÔøΩM JavaScript code for you ><
> 
> Tips:
> Have you ever heard of Infinite monkey theorem? If you click the "RCE!" button enough times you can get the flag üòâ
> 
> Author: splitline

[Attachment](https://github.com/m1dm4n/CTF-WriteUp/blob/main/2022/HITCONCTF2022/rce/rce-4bc5d3c73ac0fd8c0b098e9e7ac5a2e1c7a2fcf6.zip)

### Solution
app.js:
```javascript
const express = require('express');
const cookieParser = require('cookie-parser')
const crypto = require('crypto');

const randomHex = () => '0123456789abcdef'[~~(Math.random() * 16)];

const app = express();
app.use(cookieParser(crypto.randomBytes(20).toString('hex')));

app.get('/', function (_, res) {
    res.cookie('code', '', { signed: true })
        .sendFile(__dirname + '/index.html');
});

app.get('/random', function (req, res) {
    let result = null;
    if (req.signedCookies.code.length >= 40) {
        const code = Buffer.from(req.signedCookies.code, 'hex').toString();
        try {
            result = eval(code);
        } catch {
            result = '(execution error)';
        }
        res.cookie('code', '', { signed: true })
            .send({ progress: req.signedCookies.code.length, result: `Executing '$${code}', result = $${result}` });
    } else {
        res.cookie('code', req.signedCookies.code + randomHex(), { signed: true })
            .send({ progress: req.signedCookies.code.length, result });
    }
});

app.listen(5000);
```
The souce code is short so it just have 2 funtions: home page and random page

The home page `/` just have a button and when we click it, the server will send a GET requests to the `/random`

The random fuction will check if the length of `code` in the cookie is greater of equal 40 so it will `unhex` and `eval` the code and return `result` to us else it will random a hex char and append it to `code` in cookie

We can't manipulate the cookie because the signature but we could make the server sign a cookie we need. Just repeatly send a cookie until the next random character is a char we want.

The payload need small than 40 (20 since it's in hex format) so normal payload won't work here. My solution is using nest  evaluation(`eval(eval(somthing_here))`). Since all the code you eval will directly impact to server so from here have many way to exploit:
+ You could asign the code to a variable and then request again (but you will need a lot cookie)
+ Using `req.query.abcd` (`abcd` to fit the target length or anything you like). Only need 1 cookie and then request server with `/random?abcd={code_excute}` 
+ ...

And send the code to read the flag on the server with your signed cookie.

[Script](https://github.com/m1dm4n/CTF-WriteUp/blob/main/2022/HITCONCTF2022/rce/solve.py)



# REVERSE
Author : Jinn
# checker - 198pts
C√≥ th·ªÉ n√≥i, ƒë√¢y l√† c√¢u m√† ƒëa s·ªë c√°c top team ƒë·ªÅu l√†m n√≥ ƒë·∫ßu ti√™n, v√¨ tr√¥ng n√≥ r·∫•t l√† d·ªÖ, nh∆∞ng v√¨ l√∫c n√†y m√¨nh c√≤n thi·∫øu ki·∫øn th·ª©c n√™n gi·∫£i quy·∫øt m·ªçi chuy·ªán c√≥ ph·∫ßn h∆°i kh√≥ khƒÉn:v

ƒê√¢y c≈©ng kh√¥ng ph·∫£i l√† l·∫ßn ƒë·∫ßu m√¨nh l√†m b√†i c√≥ driver tr∆∞·ªõc ƒë√≥, m√¨nh ƒë√£ t·ª´ng l√†m m·ªôt b√†i driver t·ª´ gi·∫£i WMCTF [t·∫°i ƒë√¢y](https://lephuduc.github.io/WMCTF2022/). Nh∆∞ng kh√°c v·ªõi nh·ªØng gi·∫£i tr∆∞·ªõc, th·ª© m√† m√¨nh c√≥ th·ªÉ static analysis ho√†n to√†n ƒë·ªÉ ra flag ri√™ng v·ªõi b√†i n√†y, setup m·ªôt debugger l√† ƒëi·ªÅu B·∫ÆT BU·ªòC ƒë·ªÉ c√≥ flag m·ªôt c√°ch h·ª£p l√≠ nh·∫•t.

![](https://i.imgur.com/ZcuD1id.png)

ƒê√¢y l√† to√†n b·ªô nh·ªØng g√¨ ƒë·ªÅ cho m√¨nh, c∆° b·∫£n l√† c√≥ 1 file PE v√† 1 file driver .sys, t·∫°i ƒë√¢y c≈©ng c√≥ th·ªÉ ƒëo√°n r·∫±ng lu·ªìn th·ª±c thi c≈©ng nh∆∞ check flag ch·∫Øc ch·∫Øn s·∫Ω n·∫±m ch·ªß y·∫øu ·ªü file .sys, v√† t·∫•t nhi√™n l√∫c m√¨nh ch·∫°y ki·ªÉm file checker.exe th√¨ n√≥ b√°o l√† `driver not found`

## file checker.exe

`checker.exe` l√† file PE64 b√¨nh th∆∞·ªùng v√† ƒë√¢y l√† to√†n b·ªô code c·ªßa n√≥, m√¨nh c≈©ng kh√¥ng ph√¢n t√≠ch g√¨ nhi·ªÅu ·ªü file n√†y.

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  HANDLE FileW; // rax
  char *v4; // rcx
  char OutBuffer[4]; // [rsp+40h] [rbp-18h] BYREF
  DWORD BytesReturned; // [rsp+44h] [rbp-14h] BYREF

  FileW = CreateFileW(L"\\\\.\\hitcon_checker", 0xC0000000, 0, 0i64, 3u, 4u, 0i64);
  qword_140003620 = (__int64)FileW;
  if ( FileW == (HANDLE)-1i64 )
  {
    sub_140001010("driver not found\n");
    exit(0);
  }
  OutBuffer[0] = 0;
  DeviceIoControl(FileW, 0x222080u, 0i64, 0, OutBuffer, 1u, &BytesReturned, 0i64);
  v4 = "correct\n";
  if ( !OutBuffer[0] )
    v4 = "wrong\n";
  sub_140001010(v4);
  system("pause");
  return 0;
}
```
C∆° b·∫£n l√† n√≥ y√™u c·∫ßu device c√≥ t√™n l√† `hitcon_checker`, sau ƒë√≥ n√≥ d√πng DeviceIoControl() ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi driver n√†y.

M√¨nh c√≥ ƒë·ªçc document v·ªÅ h√†m n√†y [t·∫°i ƒë√¢y](https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) v√† n√≥ c√≥ structure nh∆∞ sau:

```cpp
BOOL DeviceIoControl(
  [in]                HANDLE       hDevice,
  [in]                DWORD        dwIoControlCode,
  [in, optional]      LPVOID       lpInBuffer,
  [in]                DWORD        nInBufferSize,
  [out, optional]     LPVOID       lpOutBuffer,
  [in]                DWORD        nOutBufferSize,
  [out, optional]     LPDWORD      lpBytesReturned,
  [in, out, optional] LPOVERLAPPED lpOverlapped
);
```
Ri√™ng v·ªÅ ch·ªï n√†y m√¨nh ch·ªâ c·∫ßn nh·ªõ tham s·ªë `dwIoControlCode`, th·ª© m√† s·∫Ω s·ª≠ d·ª•ng ƒë·ªÉ driver x·ª≠ l√≠ theo ƒë√∫ng t√≠n hi·ªáu n√†y, v√† tham s·ªë tr·∫£ v·ªÅ `lpBytesReturned`, n·∫øu b·∫±ng 1, xem nh∆∞ m√¨nh check ƒë√∫ng.

C√≥ m·ªôt ƒëi·ªÅu kh√° l√† l·∫° khi m√† kh√¥ng c√≥ ch·ªï ƒë·ªÉ m√¨nh nh·∫≠p input, ch·ªâ c√≥ g·ª≠i code cho driver v√† nh·∫≠n bytes tr·∫£ v·ªÅ th√¥i.

## file checker_drv.sys

ƒê√¢y l√† to√†n b·ªô code c·ªßa h√†m main
```c
__int64 __fastcall sub_140001B50(struct _DRIVER_OBJECT *driverObj)
{
  unsigned int v2; // edi
  _BYTE *DriverSection; // rcx
  PHYSICAL_ADDRESS PhysicalAddress; // rax
  PHYSICAL_ADDRESS v5; // rax
  unsigned __int8 v6; // al

  driverObj->DriverUnload = (PDRIVER_UNLOAD)unload_func;
  v2 = Create_n_Init(driverObj);
  driverObj->MajorFunction[0] = (PDRIVER_DISPATCH)proc_func;
  driverObj->MajorFunction[2] = (PDRIVER_DISPATCH)proc_func;
  driverObj->MajorFunction[3] = (PDRIVER_DISPATCH)proc_func;
  driverObj->MajorFunction[4] = (PDRIVER_DISPATCH)proc_func;
  DriverSection = driverObj->DriverSection;
  driverObj->MajorFunction[14] = (PDRIVER_DISPATCH)proc_func;
  DriverSection[104] |= 0x20u;
  sub_140001040();
  PhysicalAddress = MmGetPhysicalAddress((char *)sub_140001490 + 7024);
  qword_140013170 = (__int64)MmMapIoSpace(PhysicalAddress, 0x1000ui64, MmNonCached);
  qword_140013178 = qword_140013170 + 48;
  v5 = MmGetPhysicalAddress((char *)sub_140001490 - 96);
  qword_140013188 = (__int64)MmMapIoSpace(v5, 0x1000ui64, MmNonCached);
  susBytes = qword_140013188 + 1792;
  v6 = sub_140001490();
  *(_BYTE *)susBytes ^= *(_BYTE *)qword_140013188;
  *(_BYTE *)(susBytes + 1) ^= *(_BYTE *)(qword_140013188 + 1);
  *(_BYTE *)(susBytes + 2) ^= *(_BYTE *)(qword_140013188 + 2);
  *(_BYTE *)(susBytes + 3) ^= *(_BYTE *)(qword_140013188 + 3);
  *(_BYTE *)(susBytes + 4) ^= *(_BYTE *)(qword_140013188 + 4);
  *(_BYTE *)(susBytes + 5) ^= *(_BYTE *)(qword_140013188 + 5);
  *(_BYTE *)(susBytes + 6) ^= *(_BYTE *)(qword_140013188 + 6);
  *(_BYTE *)(susBytes + 7) ^= *(_BYTE *)(qword_140013188 + 7);
  *(_BYTE *)(susBytes + 8) ^= *(_BYTE *)(qword_140013188 + 8);
  *(_BYTE *)(susBytes + 9) ^= *(_BYTE *)(qword_140013188 + 9);
  *(_BYTE *)(susBytes + 10) ^= *(_BYTE *)(qword_140013188 + 10);
  *(_BYTE *)(susBytes + 11) ^= *(_BYTE *)(qword_140013188 + 11);
  *(_BYTE *)(susBytes + 12) ^= *(_BYTE *)(qword_140013188 + 12);
  *(_BYTE *)(susBytes + 13) ^= *(_BYTE *)(qword_140013188 + 13);
  *(_BYTE *)(susBytes + 14) ^= *(_BYTE *)(qword_140013188 + 14);
  *(_BYTE *)(susBytes + 15) ^= *(_BYTE *)(qword_140013188 + 15);
  *(_BYTE *)susBytes ^= *(_BYTE *)(qword_140013188 + 16);
  *(_BYTE *)(susBytes + 1) ^= *(_BYTE *)(qword_140013188 + 17);
  *(_BYTE *)(susBytes + 2) ^= *(_BYTE *)(qword_140013188 + 18);
  *(_BYTE *)(susBytes + 3) ^= *(_BYTE *)(qword_140013188 + 19);
  *(_BYTE *)(susBytes + 4) ^= *(_BYTE *)(qword_140013188 + 20);
  *(_BYTE *)(susBytes + 5) ^= *(_BYTE *)(qword_140013188 + 21);
  *(_BYTE *)(susBytes + 6) ^= *(_BYTE *)(qword_140013188 + 22);
  *(_BYTE *)(susBytes + 7) ^= *(_BYTE *)(qword_140013188 + 23);
  *(_BYTE *)(susBytes + 8) ^= *(_BYTE *)(qword_140013188 + 24);
  *(_BYTE *)(susBytes + 9) ^= *(_BYTE *)(qword_140013188 + 25);
  *(_BYTE *)(susBytes + 10) ^= *(_BYTE *)(qword_140013188 + 26);
  *(_BYTE *)(susBytes + 11) ^= *(_BYTE *)(qword_140013188 + 27);
  *(_BYTE *)(susBytes + 12) ^= *(_BYTE *)(qword_140013188 + 28);
  *(_BYTE *)(susBytes + 13) ^= *(_BYTE *)(qword_140013188 + 29);
  *(_BYTE *)(susBytes + 14) ^= *(_BYTE *)(qword_140013188 + 30);
  *(_BYTE *)(susBytes + 15) ^= *(_BYTE *)(qword_140013188 + 31);
  sub_1400014B0(v6);
  return v2;
}
```

M√¨nh ƒë√£ rename m·ªôt s·ªë h√†m, tuy nhi√™n m·ªôt s·ªë bi·∫øn nh∆∞ng m√† m√¨nh ch·ªâ c·∫ßn ph√¢n t√≠ch m·ªôt ph·∫ßn v√† hi·ªÉu l√† ƒë∆∞·ª£c.

ƒê·∫ßu ti√™n, driverObj c√≥ m·ªôt thu·ªôc t√≠nh l√† `DriverUnload`, ƒë√¢y s·∫Ω l√† h√†m ƒë∆∞·ª£c driver g·ªçi l√∫c driver stop, c√≥ th·ªÉ xem nh∆∞ l√† m·ªôt destructor trong c++ 

B·ªè qua d√≤ng th·ª© 10, ti·∫øp xem l√† thu·ªôc t√≠nh `MajorFunction`, m√¨nh d·ª±a theo list n√†y v√† hi·ªÉu c∆° b·∫£n nh∆∞ sau:
![](https://i.imgur.com/RC4q8XS.png)
Major function s·∫Ω d·ª±a v√†o IRP_MJ_* ƒë·ªÉ x√°c ƒë·ªãnh ch·ª©c nƒÉng n√†o s·∫Ω ƒë∆∞·ª£c h√†m n√†o x·ª≠ l√≠. Hay n√≥i c√°ch kh√°c `MajorFunction[14]` ho·∫∑c DEVICE_CONTROL s·∫Ω ƒë∆∞·ª£c `proc_func` (m√¨nh ƒë√£ rename) ƒë·∫£m nhi·ªám, t∆∞∆°ng t·ª± v·ªõi CREATE, CLOSE,..

C√≥ th·ªÉ n√≥i, `proc_func` s·∫Ω l√† h√†m x·ª≠ l√≠ khi giao ti·∫øp v·ªõi `checker.exe` l√∫c n√£y, nh∆∞ng m√¨nh s·∫Ω n√≥i v·ªÅ h√†m n√†y sau, v√¨ n√≥ c≈©ng kh√¥ng qu√° r·∫Øc r·ªëi.

Ti·∫øp t·ª•c v·ªõi h√†m main, 
```c
  PhysicalAddress = MmGetPhysicalAddress((char *)sub_140001490 + 7024);
  qword_140013170 = (__int64)MmMapIoSpace(PhysicalAddress, 0x1000ui64, MmNonCached);
  qword_140013178 = qword_140013170 + 48;
  v5 = MmGetPhysicalAddress((char *)sub_140001490 - 96);
  qword_140013188 = (__int64)MmMapIoSpace(v5, 0x1000ui64, MmNonCached);
  susBytes = qword_140013188 + 1792;
```
PhysicalAddress s·∫Ω l√† bi·∫øn l∆∞u gi√° tr·ªã ch√≠nh x√°c c·ªßa (sub_140001490 + 7024) ƒë∆∞·ª£c l∆∞u trong RAM, ƒë·ªãa ch·ªâ n√†y ƒë∆∞·ª£c map 0x1000 bytes.

C√≥ th·ªÉ hi·ªÉu r·∫±ng khi ƒë∆∞·ª£c map nh∆∞ v·∫≠y, c√≥ m·ªôt h√†m n√†o nƒÉm tr√™n v√πng map th√¨ khi c√°c bits v·∫≠t l√≠ ·ªü memory b·ªã thay ƒë·ªïi ƒë·ªìng nghƒ©a v·ªõi n·ªôi dung c·ªßa h√†m ƒë√≥ c≈©ng b·ªã thay ƒë·ªïi.
```c
qword_140013178 = qword_140013170 + 48;
```
qword_70 l√∫c n√†y l√† m·ªôt v√πng 0x1000 bytes, m√† qword_78 tr·ªè t·ªõi qword_70 + 48, m√† ƒë·ªìng th·ªùi ƒë·ªô d√†i c·ªßa flag l√† 48 bytes => qword_70 l√† v√πng nh·ªõ c·ªßa flag, m√¨nh s·∫Ω rename l·∫°i th√†nh `flag`, c√≤n `qword_140013170` m√¨nh s·∫Ω g·ªçi l√† space1

T∆∞∆°ng t·ª± v·ªõi 2 c√¢u l·ªánh ti·∫øp theo, ƒë·∫∑c bi·ªát ƒë·ªãa ch·ªâ c·ªßa qword_140013188 + 1792 tr√πng v·ªõi ƒë·ªãa ch·ªâ c·ªßa h√†m 

```c
char __fastcall sub_140001B30(char a1)
{
  return -98 - 17 * ((a1 - 34) ^ 0xAD);
}
```
M√¨nh t·∫°m g·ªçi n√≥ l√† space2, c√≤n susBytes s·∫Ω tr·ªè t·ªõi v·ªã tr√≠ trong memory c·ªßa h√†m n√†y. Nghƒ©a l√† khi susBytes thay ƒë·ªïi th√¨ n·ªôi dung h√†m c≈©ng b·ªã thay ƒë·ªïi.

C√≤n `qword_140013188` m√¨nh s·∫Ω rename th√†nh space2.

```c
  *(_BYTE *)susBytes ^= *(_BYTE *)space2;
  *(_BYTE *)(susBytes + 1) ^= *(_BYTE *)(space2 + 1);
  *(_BYTE *)(susBytes + 2) ^= *(_BYTE *)(space2 + 2);
  *(_BYTE *)(susBytes + 3) ^= *(_BYTE *)(space2 + 3);
  *(_BYTE *)(susBytes + 4) ^= *(_BYTE *)(space2 + 4);
  *(_BYTE *)(susBytes + 5) ^= *(_BYTE *)(space2 + 5);
  *(_BYTE *)(susBytes + 6) ^= *(_BYTE *)(space2 + 6);
  *(_BYTE *)(susBytes + 7) ^= *(_BYTE *)(space2 + 7);
  *(_BYTE *)(susBytes + 8) ^= *(_BYTE *)(space2 + 8);
  *(_BYTE *)(susBytes + 9) ^= *(_BYTE *)(space2 + 9);
  *(_BYTE *)(susBytes + 10) ^= *(_BYTE *)(space2 + 10);
  *(_BYTE *)(susBytes + 11) ^= *(_BYTE *)(space2 + 11);
  *(_BYTE *)(susBytes + 12) ^= *(_BYTE *)(space2 + 12);
  *(_BYTE *)(susBytes + 13) ^= *(_BYTE *)(space2 + 13);
  *(_BYTE *)(susBytes + 14) ^= *(_BYTE *)(space2 + 14);
  *(_BYTE *)(susBytes + 15) ^= *(_BYTE *)(space2 + 15);
  *(_BYTE *)susBytes ^= *(_BYTE *)(space2 + 16);
  *(_BYTE *)(susBytes + 1) ^= *(_BYTE *)(space2 + 17);
  *(_BYTE *)(susBytes + 2) ^= *(_BYTE *)(space2 + 18);
  *(_BYTE *)(susBytes + 3) ^= *(_BYTE *)(space2 + 19);
  *(_BYTE *)(susBytes + 4) ^= *(_BYTE *)(space2 + 20);
  *(_BYTE *)(susBytes + 5) ^= *(_BYTE *)(space2 + 21);
  *(_BYTE *)(susBytes + 6) ^= *(_BYTE *)(space2 + 22);
  *(_BYTE *)(susBytes + 7) ^= *(_BYTE *)(space2 + 23);
  *(_BYTE *)(susBytes + 8) ^= *(_BYTE *)(space2 + 24);
  *(_BYTE *)(susBytes + 9) ^= *(_BYTE *)(space2 + 25);
  *(_BYTE *)(susBytes + 10) ^= *(_BYTE *)(space2 + 26);
  *(_BYTE *)(susBytes + 11) ^= *(_BYTE *)(space2 + 27);
  *(_BYTE *)(susBytes + 12) ^= *(_BYTE *)(space2 + 28);
  *(_BYTE *)(susBytes + 13) ^= *(_BYTE *)(space2 + 29);
  *(_BYTE *)(susBytes + 14) ^= *(_BYTE *)(space2 + 30);
  *(_BYTE *)(susBytes + 15) ^= *(_BYTE *)(space2 + 31);
```
Ngay b√™n d∆∞·ªõi th√¨ h√†m sub_140001B30 (t·∫°m g·ªçi l√† decrypt) ƒë√£ b·ªã xor v·ªõi space2 v√† b·ªã thay ƒë·ªïi, nh∆∞ng l√∫c n√†y m√¨nh kh√¥ng bi·∫øt space2 l√† g√¨ v√† ƒëo·∫°n code n√†y ƒë∆∞·ª£c ch·∫°y khi m√† m√¨nh load driver xu·ªëng t·∫ßng kernel, do ƒë√≥ m√¨nh ph·∫£i setup debug m·ªõi bi·∫øt ƒë∆∞·ª£c space2 l√† g√¨.

Ti·∫øp t·ª•c quay l·∫°i h√†m `proc_func` l√† n∆°i x·ª≠ l√≠ ch√≠nh c·ªßa ch∆∞∆°ng tr√¨nh:

```c
__int64 __fastcall proc_func(struct _DEVICE_OBJECT *a1, __int64 a2)
{
  ULONG Length; // esi
  PIO_STACK_LOCATION CurrentIrpStackLocation; // rax
  char v7; // cl
  __int64 v8; // rax
  int v9; // ecx

  Length = 0;
  CurrentIrpStackLocation = IoGetCurrentIrpStackLocation((PIRP)a2);
  if ( a1 != DeviceObject )
    return 3221225473i64;
  if ( CurrentIrpStackLocation->MajorFunction )
  {
    if ( CurrentIrpStackLocation->MajorFunction == 14 )
    {
      Length = CurrentIrpStackLocation->Parameters.Read.Length;
      switch ( CurrentIrpStackLocation->Parameters.Read.ByteOffset.LowPart )
      {
        case 0x222000u:
          susFunc(0);
          byte_140013190[0] = 1;
          break;
        case 0x222010u:
          susFunc(32u);
          byte_140013191 = 1;
          break;
        case 0x222020u:
          susFunc(64u);
          byte_140013192 = 1;
          break;
        case 0x222030u:
          susFunc(96u);
          byte_140013193 = 1;
          break;
        case 0x222040u:
          susFunc(128u);
          byte_140013194 = 1;
          break;
        case 0x222050u:
          susFunc(160u);
          byte_140013195 = 1;
          break;
        case 0x222060u:
          susFunc(192u);
          byte_140013196 = 1;
          break;
        case 0x222070u:
          susFunc(224u);
          byte_140013197 = 1;
          break;
        case 0x222080u:
          if ( !Length )
            goto LABEL_15;
          v7 = 1;
          v8 = 0i64;
          while ( byte_140013190[v8] )
          {
            if ( ++v8 >= 8 )
              goto LABEL_21;
          }
          v7 = 0;
LABEL_21:
          if ( v7 )
          {
            v9 = dword_140003000 - 'ctih';
            if ( dword_140003000 == 'ctih' )
              v9 = (unsigned __int16)word_140003004 - 'no';
            **(_BYTE **)(a2 + 24) = v9 == 0;
          }
          else
          {
LABEL_15:
            **(_BYTE **)(a2 + 24) = 0;
          }
          break;
        default:
          break;
      }
    }
  }
  else
  {
    byte_140003170[(_QWORD)PsGetCurrentProcessId()] = 1;
  }
  *(_QWORD *)(a2 + 56) = Length;
  *(_DWORD *)(a2 + 48) = 0;
  IofCompleteRequest((PIRP)a2, 0);
  return 0i64;
}
```
T·∫°i ƒë√¢y ta s·∫Ω th·∫•y c·∫•u tr√∫c c·ªßa n√≥ l√† 1 switch case, m√† l√∫c n√£y checker.exe c√≥ s·ª≠ d·ª•ng code l√† 0x222080 => ch·ªâ c√≥ `case 0x222080u` ƒë∆∞·ª£c g·ªçi.

·ªû case n√†y th√¨ n√≥ check xem ƒë√£ g·ªçi 8 case ·ªü tr√™n ch∆∞a (0x222000->0x222070), N·∫øu c√≥ th√¨ n√≥ s·∫Ω ti·∫øn h√†nh ki·ªÉm tra dword_140003000 c√≥ b·∫±ng "hitcon" hay kh√¥ng, n·∫øu c√≥ th√¨ n√≥ s·∫Ω tr·∫£ v·ªÅ byte 1 cho checker.exe

T·∫°i bytes dword_140003000, ta th·∫•y n√≥ l√† flag 



















ed v·ªõi length l√† 48 (l√Ω do m√¨nh bi·∫øt flaglength l√† 48 l√∫c n√£y)

![](https://i.imgur.com/f2FQcGy.png)

Quay l·∫°i c√°c case ·ªü tr√™n, n√≥ g·ªçi 1 h√†m duy nh·∫•t nh∆∞ng c√≥ tham s·ªë kh√°c nhau 

![](https://i.imgur.com/yYFe804.png)


Trong h√†m n√†y n√≥ xor function decrypt (susBytes) v·ªõi 16 bytes ƒë·∫ßu c·ªßa space 1 k·ªÉ t·ª´ idx sau ƒë√≥ n√≥ d√πng h√†m `decrypt` ƒë·ªÉ decrypt 48 bytes c·ªßa flag, sau ƒë√≥ l·∫°i xor `decrypt` v·ªõi 16 bytes ti·∫øp theo k·ªÉ t·ª≠ idx+16.

## take note
V·∫≠y th√¨ c∆° b·∫£n flow ch∆∞∆°ng tr√¨nh ƒë√£ c√≥ th·ªÉ r√µ, c√≥ th·ªÉ t√≥m t·∫Øt l·∫°i nh∆∞ sau:

- checker.exe c√≥ s·ª≠ d·ª•ng driver check flag, khi flag tr√™n driver ƒë√∫ng th√¨ s·∫Ω tr·∫£ v·ªÅ correct
- driver c√≥ 8 h√†m x·ª≠ l√≠ flag v√† 1 h√†m check (case 0x222080)
- Khi m√† driver g·ªçi ƒë·ªß 8 h√†m tr√™n th√¨ m·ªõi ki·ªÉm tra flag ƒë∆∞·ª£c, trong m·ªói h√†m l·∫ßn l∆∞·ª£t xor bytes r·ªìi g·ªçi h√†m decrypt flag, sau ƒë√≥ xor h√†m decrypt flag ti·∫øp

## Solution

V·∫≠y ƒë·ªÉ ƒë∆∞·ª£c flag ƒë√∫ng, ta ph·∫£i t√¨m ƒë∆∞·ª£c ƒë√∫ng th·ª© t·ª± g·ªçi 8 h√†m ·ªü tr√™n, v·∫≠y vi·ªác ƒë·∫ßu ti√™n l√† ta ph·∫£i l·∫•y ƒë∆∞·ª£c space1 v√† bytes c·ªßa function decrypt sau khi ch·∫°y h·∫øt h√†m main.

Gi·ªù m√¨nh s·∫Ω setup debug:

M√°y ·∫£o m√¨nh ƒëang s·ª≠ d·ª•ng l√† Windows 10 22H2 v√† flare-vm, tools d√πng ƒë·ªÉ debug l√† Windbg, v√¨ ban ƒë·∫ßu m√¨nh d√πng windbg b·∫£n c≈© n√™n l√† h·∫ßu nh∆∞ r·∫•t kh√≥ v√† kh√¥ng th·ªÉ l√†m ƒë∆∞·ª£c. M√¨nh d√πng WinDbg Preview tr√™n `Microsoft Store`.

ƒê·∫ßu ti√™n ph·∫£i c√†i ƒë·∫∑t ƒë∆∞·ª£c driver ƒë·ªÉ test tr∆∞·ªõc:

M√¨nh d√πng OSR Driver Loader ƒë·ªÉ d√πng GUI ho·∫∑c c≈©ng c√≥ th·ªÉ d·ª±a theo [link n√†y](https://stackoverflow.com/questions/7828663/how-do-i-install-a-custom-windows-driver):

ƒê·ªëi v·ªõi OSR Driver Loader:

![](https://i.imgur.com/fjrYKrv.png)

Ch·ªçn `[Resgiser Service]` ƒë·ªÉ t·∫°o service cho driver n√†y, sau ƒë√≥ ch·ªçn `[Start Service]` ƒë·ªÉ kh·ªüi ƒë·ªông service, t∆∞∆°ng t·ª´ b·∫•m stop v√† Unregister ƒë·ªÉ d·ª´ng v√† hu·ª∑ b·ªè.

T∆∞∆°ng t·ª± c√°ch tr√™n nh∆∞ng c√πng cmd:

Register Service: `sc create hitcon_checker binPath= [full path to your .sys file] type= kernel`

Start service: `sc start hitcon_checker`

>ƒê·ªëi v·ªõi c√°c b·∫°n kh√¥ng resgister ƒë∆∞·ª£c v√¨ driver kh√¥ng c√≥ signature, hay n√≥i c√°ch kh√°c Windows n√≥i ƒë√≥ l√† driver kh√¥ng r√µ ngu·ªìn g·ªëc n√™n kh√¥ng c√†i ƒë∆∞·ª£c, tuy nhi√™n c√≥ th·ªÉ t·∫Øt ch·ª©c nƒÉng n√†y khi kh·ªüi ƒë·ªông windows, m√¨nh l√†m theo h∆∞·ªõng d·∫´n ·ªü link n√†y ho·∫∑c c√°c b·∫°n c√≥ th·ªÉ d√πng [VirtualKD-Redux](https://github.com/4d61726b/VirtualKD-Redux) -> taget64 -> vminstall.exe, Sau ƒë√≥ b·∫•m F8 v√† ch·ªçn [Disable driver signature enforcement]

Sau khi kh·ªüi ƒë·ªông service th√¨ khi ch·∫°y checker.exe s·∫Ω c√≥ th√¥ng b√°o nh∆∞ sau l√† th√†nh c√¥ng:

![](https://i.imgur.com/P5qG7Nt.png)

Ti·∫øn h√†nh debug driver th√¥i, b√¢y gi·ªù c√°c b·∫°n l√†m l·∫°i b∆∞·ªõc `taget64 -> vminstall.exe -> install `, ti·∫øp t·ª•c F8 v√† ch·ªçn [Disable driver signature enforcement] tuy nhi√™n c√πng l√∫c n√†y, khi m√† Icon windows hi·ªán l√™n th√¨ ·ªü m√°y host m·ªü vmmon64.exe l√™n:

![](https://i.imgur.com/6IoXMjc.png)

Ch·ªçn WinDbg Preview v√† Ch·ªçn [Run debugger]

![](https://i.imgur.com/KPLVolL.png)

L√∫c n√†y setup m√†n h√¨nh disassembly v√† m√°y ·∫£o ƒë·ª©ng nh∆∞ th·∫ø n√†y xem nh∆∞ th√†nh c√¥ng:v

![](https://i.imgur.com/4VBruAn.png)

B·∫•m go ƒë·ªÉ m√°y ti·∫øp t·ª•c ch·∫°y

![](https://i.imgur.com/c4dsopH.png)

L√∫c n√†y, kh·ªüi ƒë·ªông l·∫°i driver c·ªßa b√†i, n·∫øu th√†nh c√¥ng ta s·∫Ω th·∫•y checker_drv.sys trong driver list:

![](https://i.imgur.com/VRVGgOK.png)

Quay l·∫°i Windbg, d·ª±a v√†o ƒë·ªãa ch·ªâ base c·ªßa driver, t√¨m d∆∞·ª£c v·ªã tr√≠ c·ªßa driver ƒë√≥ trong memory:

![](https://i.imgur.com/Z553fu3.png)

D·ª±a v√†o ƒë·ªãa ch·ªâ c·ªßa h√†m decrypt trong IDA, m√¨nh t√¨m ƒë∆∞·ª£c h√†m `decrypt` trong m√†n h√¨nh memory l√† `base + 0x1b30`

```c
char __fastcall sub_140001B30(char a1)
{
  return -98 - 17 * ((a1 - 34) ^ 0xAD);
}
```
![](https://i.imgur.com/Er6xSsv.png)
L√∫c n√†y, r√µ r√†ng n√≥ ƒë√£ ƒëi qua h√†m main n√™n bytes c·ªßa n√≥ ƒë√£ b·ªã thay ƒë·ªïi so v·ªõi ban ƒë·∫ßu, v√¨ c·∫ßn l∆∞u bytes n√†y l·∫°i t√≠nh to√°n, n√™n m√¨nh d√πng l·ªánh db ƒë·ªÉ l·∫•y bytes n√†y ra:

![](https://i.imgur.com/bNhf02y.png)

```python
func = bytes.fromhex('88 31 20 13 55 b4 4f 48 f3 18 4f 5b b0 29 9e c7 00 2a c1 c3')
```
T∆∞∆°ng t·ª± m√¨nh c·∫ßn l·∫•y ra 0xe0 + 32 bytes c·ªßa space2

![](https://i.imgur.com/6ilI7Bt.png)


```python
space2 = bytes.fromhex("""
19 bc 8f 82 d0 2c 61 34 c0 9f f6 50 d5 fb 0c 6e
d0 eb e5 e3 ce b5 4c ca 45 aa 11 b2 3e 62 6f 7d
d0 eb a9 e3 b2 2f 06 47 7c 28 c5 de de 1a 4e d6
d8 2d 93 4f 82 65 64 fd 08 62 4b 87 7e 52 47 30
b7 ba d0 39 68 53 50 ab 20 d5 ca 84 26 71 6f 91
1b 36 46 11 a5 f1 4e 58 6c 74 d4 9c 15 e2 28 d5
d9 0f 3d 83 f3 fc d1 13 1a 62 12 40 aa ea cd cb
e1 c6 08 81 98 f6 68 88 be 23 b5 9e 55 b9 e2 7d
5a da 39 07 f0 2e 32 20 59 56 4c b4 8f 3e 07 61
d9 0f 2d 61 f1 91 33 14 cb 49 68 fe 1f d4 8a fe
e1 c6 18 63 9a 9b 8a 8a 7f 08 c3 e8 e1 ec 0b 8f
3b 00 94 a5 11 e7 47 66 c4 9f 98 18 70 f0 30 f6
94 71 b1 95 d1 f0 6f b7 d9 3d 05 9e c1 53 33 76
9b 4b 69 ca de fd 7d 67 b8 29 2b c7 c5 84 2c d1
87 87 f1 98 97 74 ad 4b 32 f0 4a 51 72 ea 09 f7
38 fd 27 bd 1c 52 71 43 95 9c 1a 86 f2 c0 f9 f8""")
```

T·ªõi ƒë√¢y th√¨ m√¨nh c√≥ th·ªÉ t√¨m th·ª© t·ª± c√°c h√†m trong switch case ho·∫°t ƒë·ªông b·∫±ng c√°ch bruteforce c√°c opcode c√°c h√†m, v√¨ sau khi x·ª≠ l√≠ xong, c√°c bytes c·ªßa h√†m b·ªã bi·∫øn ƒë·ªïi sau cho c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë∆∞·ª£c h√†m sau s·ª≠ d·ª•ng ƒë∆∞·ª£c, n√™n t·ªïng s·ªë l·∫ßn m√¨nh c·∫ßn brute r·∫•t √≠t (2+3+4+5+6+7+8) = 35 l·∫ßn

```python
from pwn import *
# print(xor(x2[:16],b2[:16]).hex() + x2[16:].hex())
#important offset
#0xfffff80664800000
#1b30 miniencrypt
#3000 flag
# origin = b'\x80\xe9"\x80\xf1\xad\x0f\xb6\xc1k\xc8\x11\xb8\x9e\x00\x00\x00*\xc1\xc3'
func = bytes.fromhex('88 31 20 13 55 b4 4f 48 f3 18 4f 5b b0 29 9e c7 00 2a c1 c3')

space2 = bytes.fromhex("""
19 bc 8f 82 d0 2c 61 34 c0 9f f6 50 d5 fb 0c 6e
d0 eb e5 e3 ce b5 4c ca 45 aa 11 b2 3e 62 6f 7d
d0 eb a9 e3 b2 2f 06 47 7c 28 c5 de de 1a 4e d6
d8 2d 93 4f 82 65 64 fd 08 62 4b 87 7e 52 47 30
b7 ba d0 39 68 53 50 ab 20 d5 ca 84 26 71 6f 91
1b 36 46 11 a5 f1 4e 58 6c 74 d4 9c 15 e2 28 d5
d9 0f 3d 83 f3 fc d1 13 1a 62 12 40 aa ea cd cb
e1 c6 08 81 98 f6 68 88 be 23 b5 9e 55 b9 e2 7d
5a da 39 07 f0 2e 32 20 59 56 4c b4 8f 3e 07 61
d9 0f 2d 61 f1 91 33 14 cb 49 68 fe 1f d4 8a fe
e1 c6 18 63 9a 9b 8a 8a 7f 08 c3 e8 e1 ec 0b 8f
3b 00 94 a5 11 e7 47 66 c4 9f 98 18 70 f0 30 f6
94 71 b1 95 d1 f0 6f b7 d9 3d 05 9e c1 53 33 76
9b 4b 69 ca de fd 7d 67 b8 29 2b c7 c5 84 2c d1
87 87 f1 98 97 74 ad 4b 32 f0 4a 51 72 ea 09 f7
38 fd 27 bd 1c 52 71 43 95 9c 1a 86 f2 c0 f9 f8""")

print(space2)
print(hex(len(space2)))
#0 32 224

def decryptflag(idx):
    tmpFunc = xor(func[:16],space2[idx:idx+16]) + func[16:]
    print(idx,tmpFunc.hex())
    tmpFunc = xor(tmpFunc[:16],space2[idx+16:idx+32]) + func[16:]
    return tmpFunc
for i in [0,32,64,96,128,160,192,224]:
    decryptflag(i)
```
```
0 918daf9185982e7c3387b90b65d292a9002ac1c3                                                                                         
32 58da89f0e79b490f8f308a856e33d011002ac1c3                                                                                       
64 3f8bf02a3de71fe3d3cd85df9658f156002ac1c3
96 513e1d90a6489e5be97a5d1b1ac3530c002ac1c3
128 d2eb1914a59a7d68aa4e03ef3f1799a6002ac1c3
160 69f73870cf2fc5c28c108cb351c59548002ac1c3
192 1c409186844420ff2a254ac5717aadb1002ac1c3
224 0fb6d18bc2c0e203c1e8050ac2c39730002ac1c3
```

Th·ª≠ 8 shellcode n√†y tr√™n https://onlinedisassembler.com/odaweb/ th√¨ m√¨nh th·∫•y 224 l√† h·ª£p l√≠ nh·∫•t, t∆∞∆°ng ·ª©ng v·ªõi code 0x222070u

![](https://i.imgur.com/yT4Fhgp.png)

T∆∞∆°ng t·ª± v·ªõi 27 l·∫ßn n·ªØa, m√¨nh t√¨m ƒë∆∞·ª£c th·ª© t·ª± r·∫•t h·ª£p l√≠ khi m√† h√†m cu·ªëi khi disassembly nh∆∞ n√†y:

![](https://i.imgur.com/3F1Mgn4.png)

ƒê√¢y l√† th·ª© t·ª± c·ªßa c√°c tham s·ªë:

`[224,64,192,0,32,128,96,160]`

T∆∞∆°ng ·ª©ng v·ªõi c√°c code \

```
[0x222070u,0x222020u,0x222050u,0x222000u,0x222010u,0x222040u,0x222030u,0x222060u]
```
ƒê·ªÉ g·ª≠i c√°c code n√†y l√™n driver th√¨ m√¨nh c√≥ 1 c√°ch l√† t·∫°o ra 8 c√°i file kh√°c nhau, m·ªói file c√≥ 1 s·ªë 0x2220_0 thay ƒë·ªïi t·ª´ file g·ªëc l√† 
```c
DeviceIoControl(FileW, 0x222080u, 0i64, 0, OutBuffer, 1u, &BytesReturned, 0i64);
```
ƒê√¢y l√† script c·ªßa m√¨nh
```py
f = open('checker.exe','rb')
b = f.read()
# for i in range(len(b)-5):
#     if b[i:i+5]==b'\xba\x80\x20\x22\x00':
#         print(i)
print(b[1290])
order = [0,32,64,96,128,160,192,224]
x = [b'\x00',b'\x10',b'\x20',b'\x30',b'\x40',b'\x50',b'\x60',b'\x70']
for i in range(len(order)):
    tmpFile = open(f'checker{order[i]}.exe','wb')
    tmpFile.write(b[:1290] + x[i]+b[1291:])
    tmpFile.close()    
```

![](https://i.imgur.com/a49jjGL.png)

Load file v√†o M√°y ·∫£o v√† ch·∫°y l·∫ßn l∆∞·ª£t theo th·ª© t·ª± ·ªü tr√™n, n·∫øu th√†nh c√¥ng, khi ch·∫°y file checker.exe n√≥ s·∫Ω th√¥ng b√°o nh∆∞ th·∫ø n√†y:

![](https://i.imgur.com/OCkQzsG.png)

ƒê·ªìng nghƒ©a l√† flag ƒë√£ ƒë√∫ng v√† n·∫±m trong memory.

Check ƒë·ªãa ch·ªâ base + 0x3000 ta s·∫Ω th·∫•y flag:

![](https://i.imgur.com/HVLwiVt.png)

Flag: `hitcon{r3ally_re4lly_rea11y_normal_checker}`

# Meow Way - 193pts

V·ªÅ c∆° b·∫£n th√¨ b√†i n√†y d·ªÖ h∆°n b√†i tr∆∞·ªõc kh√° nhi·ªÅu flow c≈©ng d·ªÖ ƒë·ªçc h∆°n, ch·ªâ kh√°c l√† n√≥ √°p d·ª•ng m·ªôt kƒ© thu·∫≠t ƒë·∫∑c bi·ªát c√≥ t√™n l√† [heaven's gate](https://www.malwarebytes.com/blog/news/2018/01/a-coin-miner-with-a-heavens-gate) m√¨nh bi·∫øt ƒë∆∞·ª£c t·ª´ a @mochi v√† anh g·ª≠i cho m√¨nh blog n√†y.

Tr∆∞·ªõc h·∫øt xem qua th·ª≠ file duy nh·∫•t m√† ƒë·ªÅ b√†i cho m√¨nh:

Load file b·∫±ng IDA32 v√† ƒë√¢y l√† to√†n b·ªô h√†m main c·ªßa n√≥

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+0h] [ebp-24h]
  int v6; // [esp+14h] [ebp-10h]
  int v7[2]; // [esp+18h] [ebp-Ch] BYREF

  v7[0] = -1;
  v7[1] = -1;
  if ( argc < 2 )
  {
    sub_401340("Usage: %s <flag>\n", (char)*argv);
    exit(1);
  }
  if ( strlen(argv[1]) != 48 )
  {
    sub_401340("Wrong length\n", v4);
    exit(1);
  }
  v6 = (int)argv[1];
  dword_40544C(v6, v6 >> 31, v6, v6 >> 31, 196, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_4053A8(v6, v6 >> 31, v6, v6 >> 31, 22, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_4053B4(v6, v6 >> 31, v6, v6 >> 31, 142, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_4053F0(v6, v6 >> 31, v6, v6 >> 31, 119, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_405448(v6, v6 >> 31, v6, v6 >> 31, 5, 0, v7, (int)v7 >> 31);
  ++v6;
 ...
  ++v6;
  dword_405428(v6, v6 >> 31, v6, v6 >> 31, 254, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_405460(v6, v6 >> 31, v6, v6 >> 31, 151, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_40540C(v6, v6 >> 31, v6, v6 >> 31, 249, 0, v7, (int)v7 >> 31);
  ++v6;
  dword_4053F4(v6, v6 >> 31, v6, v6 >> 31, 152, 0, v7, (int)v7 >> 31);
  dword_405438(v6 + 1, (v6 + 1) >> 31, v6 + 1, (v6 + 1) >> 31, 101, 0, v7, (int)v7 >> 31);
  v5 = memcmp(&unk_405018, argv[1], 0x30u);
  if ( v5 )
  {
    sub_401340("Wrong\n", v5);
    exit(-1);
  }
  sub_401340("I know you know the flag!\n", 0);
  return 0;
}
```
ƒê·∫ßu ti√™n l√† ch∆∞∆°ng tr√¨nh check length c·ªßa flag xem c√≥ b·∫±ng 48 k√≠ t·ª± kh√¥ng, sau ƒë√≥ th√¨ v·ªõi m·ªói k√≠ t·ª± c√≥ 1 h√†m encrypt ri√™ng bi·ªát v·ªõi c√°c tham s·ªë kh√°c nhau.

Sau c√πng l√† compare v·ªõi unk_405018(encryted flag) v√† th√¥ng b√°o k·∫øt qu·∫£.

T·ª´ng dword_* s·∫Ω tr·ªè v·ªÅ 1 h√†m b·∫•t k√¨:

```c
void sub_401060()
{
  dword_405400 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))"j3√®";
}
```

V√† ƒë√¢y l√† n·ªôi dung c·ªßa h√†m ƒë√≥:

![](https://i.imgur.com/vHenZ2B.png)

L√∫c n√†y m√¨nh th·ª≠ debug m·ªõi xem ƒë∆∞·ª£c t·ª´ng h√†m n√≥ l√†m g√¨:
Set Parameter l√† 1 chu·ªói b·∫•t k√¨ c√≥ lenght = 48

![](https://i.imgur.com/l6DNkpd.png)

![](https://i.imgur.com/qJfOtA8.png)

Khi m√¨nh stepinto v√† ƒëi h·∫øt ƒëo·∫°n n√†y th√¨ ch∆∞∆°ng tr√¨nh t·ª± out lu√¥n, ch·∫Øc l√† c√≥ l·ªói g√¨ ƒë√≥ ·ªü ch·ªï n√†y

N·∫øu ki·ªÉm tra kƒ©, ta s·∫Ω th·∫•y ph√≠a d∆∞·ªõi th·ª±c s·ª± c√≤n 1 ƒëo·∫°n code n·ªØa nh∆∞ng n√≥ kh√¥ng ch·∫°y

![](https://i.imgur.com/VKabHAP.png)

M√¨nh th·ª≠ ki·ªÉm tra t∆∞∆°ng t·ª± v·ªõi c√°c h√†m kh√°c, th√¨ n√≥ c≈©ng ra k·∫øt qu·∫£ t∆∞∆°ng t·ª±, tuy nhi√™n ch·ªâ kh√°c nhau m·ªôt v√†i ch·ªï nh∆∞ `xor cl, <num>`, v√† m·ªôt s·ªë h√†m sub thay v√¨ add, ...

C∆° b·∫£n l√† ƒëo·∫°n code ph√≠a tr√™n l√†m nhi·ªÖu kh√° nhi·ªÅu, khi·∫øn m√¨nh kh√¥ng th·ª±c s·ª± bi·∫øt l√† n√≥ th·ª±c s·ª± l√†m g√¨.

Nh∆∞ ƒë·∫ßu b√†i m√¨nh ƒë√£ n√≥i, file n√†y l√† file PE32 nh∆∞ng d√πng kƒ© thu·∫≠t `heaven's gate` n√™n ƒëo·∫°n ƒë√≥ n√≥ c√≥ th·ªÉ ch·∫°y ƒë∆∞·ª£c code c·ªßa 64bits (m√¨nh bi·∫øt s∆° nh∆∞ v·∫≠y:v). Do ƒë√≥ ƒëo·∫°n shellcode ph√≠a sau l√† c·ªßa 64bit. M√¨nh d√πng web n√†y ƒë·ªÉ disassemble:

[onlinedisassembler](https://onlinedisassembler.com/odaweb/)

ƒê·ªëi v·ªõi function ƒë·∫ßu ti√™n:

![](https://i.imgur.com/v4EMYz9.png)

```
6a33e80000000083042405cb4831c065488b4060480fb64002678b4c241c67890185c07518678b7c2404678b74240c678b4c241467020e80f1ba67880fe800000000c7442404230000008304240dcbc30000000000000000
```

![](https://i.imgur.com/XdXqHaj.png)

C√≥ m·ªôt ƒëi·ªÅu th√∫ v·ªã l√† kƒ© thu·∫≠t n√†y ch·ªâ anti debug thui, c√≤n ƒë·ªçc th√¨ c∆° b·∫£n v·∫´n ƒë·ªçc ƒë∆∞·ª£c =)), th·∫ø m√† kh√¥ng hi·ªÉu sao l√∫c ƒë·∫ßu ƒë·ªçc kh√¥ng ra, chuy·ªÉn qua x64 c≈©ng th·∫•y kh√¥ng kh√°c g√¨ nhi·ªÅu nh∆∞n m√† l·∫°i l√†m ra =)), t√¢m l√≠ qu√°.

M√¨nh ch·ªâ c·∫ßn quan tr·ªçng ƒëo·∫°n n√†y th√¥i:

![](https://i.imgur.com/ts4J1xW.png)

d·ª±a v√†o thanh ghi esi, edi, v√† cl c√≥ th·ªÉ suy ra n√≥ encrypt byte c·ªßa flag nh∆∞ sau:

![](https://i.imgur.com/GUc0nTE.png)

ƒê·ªëi v·ªõi h√†m n√†y th√¨ s·∫Ω d·ªãch sang python nh∆∞ n√†y:

```python
def add(para,func,encrypted):
    return ((para+i)^func)&0xff
```

T∆∞∆°ng t·ª± v·ªõi c√°c h√†m cho ƒë·∫øn khi h√†m th·ª© 6 th√¨ n√≥ s·∫Ω kh√°c ƒëi 1 ch√∫t l√† thay v√¨ c·ªông s·∫Ω h√†nh ph√©p tr·ª´:

```python
def sub(para,func,encrypted):
    return ((para-i)^func)&0xff
```

T·ªõi ƒë√¢y m√¨nh th·ª≠ gi·∫£i ra flag

Tr∆∞·ªõc ti√™n m√¨nh c·∫ßn ph·∫£i c√≥ t·∫•t c·∫£ c√°c tham s·ªë m√† n√≥ truy·ªÅn v√†o v√† flag encrypted:

```python
para=[196,22,142,119,5,185,13,107,36,85,18,53,118,231,251,160,218,52,132,180,200,155,239,180,185,10,87,92,254,197,106,115,73,189,17,214,143,107,10,151,171,78,237,254,151,249,152,101]
encrypted=b"\x96P\xcf,\xeb\x9b\xaa\xfbS\xabs\xddl\x9e\xdb\xbc\xee\xab#\xd6\x16\xfd\xf1\xf0\xb9u\xc3(\xa2t}\xe3'\xd5\x95\\\xf5vu\xc9\x8c\xfbB\x0e\xbdQ\xa2\x98"
```

Ti·∫øp theo l√† t√¨m c√°ch l·∫•y c√°c tham s·ªë n·∫±m b√™n trong h√†m:

![](https://i.imgur.com/2NDMnlw.png)

D·ª±a v√†o c√°c ƒë·ªãa ch·ªâ n√†y, ta l·∫•y 4 bytes ƒë·∫ßu l√† ƒë∆∞·ª£c ƒë·ªãa ch·ªâ c·ªßa h√†m
```python
int.from_bytes(get_bytes(i,4),'little')
```
T·ª´ 4 bytes n√†y m√¨nh s·∫Ω l·∫•y ƒë∆∞·ª£c to√†n b·ªô h√†m, tuy nhi√™n ta ch·ªâ c·∫ßn l·∫•y bytes m√† l√∫c n√≥ xor, d·ª±a v√†o opcode v√† thanh ghi c·ªßa l·ªánh `xor cl, <num>`, m√¨nh bi·∫øt ƒë∆∞·ª£c ch·ªâ c·∫ßn l·∫•y byte n·∫±m sau b'\xf1' l√† c√≥ ƒë∆∞·ª£c s·ªë c·∫ßn xor.

T·ªõi ƒë√¢y ch·ªâ c·∫ßn rev l·∫°i 2 h√†m sub v√† add r·ªìi decrypt flag ra th√¥i:v.

```python
from pwn import *
encrypted=b"\x96P\xcf,\xeb\x9b\xaa\xfbS\xabs\xddl\x9e\xdb\xbc\xee\xab#\xd6\x16\xfd\xf1\xf0\xb9u\xc3(\xa2t}\xe3'\xd5\x95\\\xf5vu\xc9\x8c\xfbB\x0e\xbdQ\xa2\x98"
para=[196,22,142,119,5,185,13,107,36,85,18,53,118,231,251,160,218,52,132,180,200,155,239,180,185,10,87,92,254,197,106,115,73,189,17,214,143,107,10,151,171,78,237,254,151,249,152,101]

offset = [0x77544C,0x7753A8,0x7753B4,0x7753F0,0x775448,0x7753FC,0x775400,0x775410,0x7753F8,0x775430,0x7753D0,0x775434,0x77545C,0x775454,0x7753C0,0x7753E4,0x7753C4,0x775440,0x7753BC,0x7753AC,0x775408,0x7753D8,0x7753B8,0x7753C8,0x7753E0,0x775418,0x7753EC,0x775414,0x775450,0x7753E8,0x7753D4,0x77541C,0x77542C,0x775444,0x775458,0x775420,0x7753B0,0x7753DC,0x775464,0x7753CC,0x775424,0x77543C,0x775404,0x775428,0x775460,0x77540C,0x7753F4,0x775438]
#[get_bytes(int.from_bytes(get_bytes(i,4),'little') + 0x30,16) for i in offset]
func = [186, 47, 205, 246, 159, 208, 34, 247, 208, 31, 168, 61, 199, 165, 71, 104, 215, 74, 150, 145, 46, 25, 197, 227, 136, 189, 78, 147, 19, 241, 204, 71, 171, 201, 72, 43, 9, 80, 79, 233, 192, 94, 239, 139, 133, 203, 85, 112]

def add(para,func,encrypted):
    for i in range(0x2f,0x7f):
        if ((para+i)^func)&0xff==encrypted:
            print(chr(i))
            return i
def sub(a,b,c):
    for i in range(0x2f,0x7f):
        if ((a-i)^b)&0xff==c:
            print(chr(i))
            return i

flag = ""
for i in range(len(func)):
    try:
        flag+=chr(add(para[i],func[i],encrypted[i]))
    except:
        flag+=chr(sub(para[i],func[i],encrypted[i]))
print(flag)
#hitcon{___7U5T_4_S1mpIE_xB6_M@G1C_4_mE0w_W@y___}
```
Sorry m·ªçi ng∆∞·ªùi v√¨ l√∫c ƒë√≥ m√¨nh l√†m ng∆∞·ª£c l·∫°i kh√¥ng ra m√† m√¨nh g·∫•p qu√° n√™n d√πng c√°ch brute lu√¥n =))).

Flag: ```hitcon{___7U5T_4_S1mpIE_xB6_M@G1C_4_mE0w_W@y___}```